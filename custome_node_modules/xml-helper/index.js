var entrie = ""
var descriptionStart = false
var firstLine = true

async function readXmlFile(FileSystem, readline, events, fileType, fileEntries) {
    try {
        const readLine = readline.createInterface({
            input: FileSystem.createReadStream(fileType, 'utf-8'),      
            crlfDelay: Infinity
        });
  
        readLine.on('line', (line) => {    
            var lineStr = ''       
            for (var i = 1; i < line.length; i += 2)
                lineStr += line[i];          
        
            if (lineStr.includes('<rdf:Description')) {
                descriptionStart = true   
          
                if (firstLine) {            
                    fileEntries.push(processFirstLine(entrie))           
                    entrie = ''
                    firstLine = false 
                }
            } else if (lineStr.includes('</rdf:Description>')) {
                descriptionStart = false
                entrie += lineStr + '\n'
                fileEntries.push(entrie)
                entrie = ''
            }
        
            if (descriptionStart) {
                entrie += lineStr + '\n'
            } else {
                if (firstLine) 
                    entrie += line;                
            }        
        });
  
        await events.once(readLine, 'close');            

    } catch (err) {
        console.error(err);
    }
}

function processFirstLine(firstLine) {  
    var newFirstLine = ''     
    for (var i = 0; i < firstLine.length; i += 2)
        newFirstLine += firstLine[i];
                
    return newFirstLine + '\n'     
}

function mapDescriptions(descriptionArray, map) {
    // extracting what is current description about
    // example: <rdf:Description rdf:about="#ACLineSegment">,
    // is about ACLineSegment, use this value as a key for whole description
    descriptionArray.forEach(description => {                
        i = description.indexOf("rdf:about=") + 'rdf:about="'.length +1 
        // +1 for # sign, example: rdf:about="#ACDCTerminal"
        rdfAbout = ''       
        // example: rdf:about="#ACDCTerminal", looking for closing quotation marks 
        while (description[i] != '"') 
            rdfAbout += description[i++];
                
        if (!map.has(rdfAbout)) {
            map.set(rdfAbout, description)
        } else {            
            if (map.get(rdfAbout) != description) {
                bidirectionalDescription = map.get(rdfAbout) + description
                map.set(rdfAbout, bidirectionalDescription)
            }
        }                
    });    
}

function extractCommonAttributes(
    mapCrudeAttributes,          
    objectTypes,
    extractedAttributes 
) {            
    mapCrudeAttributes.forEach((attributeSet, type) => {        
        objectTypes.add(type)
        attributeSet.forEach(attribute => {
            extractedAttributes.add(getClassTypeFromCIM(attribute))
        });
    });    

    extractedAttributes.delete('type')
}

function generateRDFS(
    firstLine,
    descriptions, 
    mapClassAttributesToClassType,
    objectTypes,
    extractedAttributes,
    enumSet
) {    
    var content = '<?xml version="1.0" encoding="utf-8"?>' + '\n' + firstLine
        
    // add class hierarchy
    const hierarchySet = new Set
    const missingClassSet = new Set
    objectTypes.forEach(type => {        
        resolveHierarchy(descriptions, type, hierarchySet, missingClassSet)        
    });    
    hierarchySet.forEach(description => {
        content += description
    });
    missingClassSet.forEach(classType => {
        console.log('\tmissing CLASS description: <' + classType + '>')
    });
       
    // add attributes
    extractedAttributes.forEach(attribute => {        
        if (descriptions.has(attribute)) {
            content += descriptions.get(attribute)
        } else {            
            mapClassAttributesToClassType.forEach((attributeSet, type) => {                                   
                if (attributeSet.has('http://iec.ch/TC57/CIM100#' + attribute)) {
                    console.log('\tmissing atrttribute description: <' + attribute + '>, for: <' + type + '>, class')
                }
            }); 
        }
    });

    // add enum classes and their values
    enumSet.forEach(enumType => {
        if (!descriptions.has(enumType))
            console.log('\tmissing enum class description: <' + enumType + '>');
    });
    descriptions.forEach((description, about) => {   
        if (enumSet.has(about.split('.')[0]))
            content += description;                    
    });

    return content + '</rdf:RDF>'
}

function resolveHierarchy(descriptions, type, hierarchySet, missingClassSet) {
    if (type == null)
        return;

    if (descriptions.has(type)) {
        description = descriptions.get(type)        
        hierarchySet.add(description)
        
        resolveHierarchy(
            descriptions, 
            extractSubClassType(description), 
            hierarchySet, 
            missingClassSet
        );        
    } else {
        missingClassSet.add(type)
        return
    } 
}

function extractSubClassType(description) {
    // example of line of interest inside description:
    // ...
    // <rdfs:subClassOf rdf:resource="#Conductor"/>
    // ...
    i = description.indexOf('rdfs:subClassOf')    
    if (i == -1) 
        return null; // recursion reached top most class (IdentifiedObject)
    else {
        i += 'rdfs:subClassOf rdf:resource="#'.length
        subClassType = ''        
        // seartching for ending quotation mark: Conductor"<--
        while (description[i] != '"') 
            subClassType += description[i++];
        
        return subClassType
    }    
}

module.exports = { 
    readXmlFile,
    mapDescriptions,
    extractCommonAttributes,
    generateRDFS
};

function getClassTypeFromCIM(CIMClassType) {
    // example of CIMClassType string: http://iec.ch/TC57/CIM100#VoltageLimit
    // split it on # character and return right part    
    return CIMClassType.split("#")[1];
}